using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NullObjGenerator
{

    [Generator]
    public class NullObjGenerator : ISourceGenerator
    {
        private IEnumerable<InterfaceDeclarationSyntax> FindMarkedInterfaces(GeneratorExecutionContext context)
        {
            return context.Compilation.SyntaxTrees
                    .SelectMany(st => st.GetRoot()
                            .DescendantNodes()
                            .Where(n => n is InterfaceDeclarationSyntax)
                            .Select(n => n as InterfaceDeclarationSyntax)
                            .Where(r => r.AttributeLists
                                .SelectMany(al => al.Attributes)
                                .Any(a => a.Name.GetText().ToString() == "GenerateNullObject")));
        }

        private SyntaxNode GenerateRoot(ClassDeclarationSyntax c, NamespaceDeclarationSyntax ns, IEnumerable<UsingDirectiveSyntax> usings)
        {
            var autoGenComment = SyntaxFactory.Comment("// <auto-generated />");

            return SyntaxFactory
                .NamespaceDeclaration(ns.Name)
                .AddUsings(usings.ToArray())
                .AddMembers(c)
                .WithLeadingTrivia(autoGenComment);
        }

        private NamespaceDeclarationSyntax FetchNamespaces(InterfaceDeclarationSyntax mi)
        {
            return mi.Ancestors()
                    .Where(n => n is NamespaceDeclarationSyntax)
                    .Select(n => n as NamespaceDeclarationSyntax)
                    .First();
        }

        private IEnumerable<UsingDirectiveSyntax> FetchUsings(InterfaceDeclarationSyntax mi)
        {
            return mi.Ancestors().Last().ChildNodes()
                    .Where(n => n is UsingDirectiveSyntax)
                    .Select(n => n as UsingDirectiveSyntax);
        }

        private string FetchOriginalInterfaceName(InterfaceDeclarationSyntax mi)
        {
            return mi.Identifier.Text;
        }

        private PropertyDeclarationSyntax GenerateStaticInstance(string className)
        {
            return SyntaxFactory.PropertyDeclaration(
                SyntaxFactory.IdentifierName(className),
                SyntaxFactory.Identifier("Instance")
            ).WithModifiers(
                SyntaxFactory.TokenList([SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword)])
            ).WithAccessorList(SyntaxFactory.AccessorList(
                SyntaxFactory.SingletonList<AccessorDeclarationSyntax>(
                    SyntaxFactory
                        .AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                        .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken))
                ))
            ).WithInitializer(
                SyntaxFactory.EqualsValueClause(
                    SyntaxFactory.ObjectCreationExpression(
                        SyntaxFactory.IdentifierName(className)
                    ).WithArgumentList(SyntaxFactory.ArgumentList())
                )
            ).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        private ClassDeclarationSyntax GenerateClass(string className, string interfaceName, IEnumerable<PropertyDeclarationSyntax> properties, IEnumerable<MethodDeclarationSyntax> methods)
        {
            return SyntaxFactory
                    .ClassDeclaration(className)
                    .AddMembers(GenerateStaticInstance(className))
                    .AddMembers(properties.ToArray())
                    .AddMembers(methods.ToArray())
                    .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                    .AddBaseListTypes(SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName(interfaceName)));
        }

        private IEnumerable<PropertyDeclarationSyntax> FetchPropertiesToImplement(InterfaceDeclarationSyntax mi)
        {
            return mi.DescendantNodes()
                    .Where(n => n is PropertyDeclarationSyntax)
                    .Select(n => n as PropertyDeclarationSyntax);
        }

        private IEnumerable<MethodDeclarationSyntax> FetchMethodsToImplement(InterfaceDeclarationSyntax mi)
        {
            return mi.DescendantNodes()
                    .Where(n => n is MethodDeclarationSyntax)
                    .Select(n => n as MethodDeclarationSyntax);
        }

        private ExpressionSyntax FetchInitialiser(PropertyDeclarationSyntax p)
        {
            var type = p.Type;

            if(p.Type is PredefinedTypeSyntax pdt)
            {
                switch(pdt.Keyword.Kind())
                {
                    case SyntaxKind.StringKeyword:
                        return SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(""));
                    case SyntaxKind.IntKeyword:
                        return SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(0));
                    default:
                        break;
                }
                
            }
            else if(p.Type is GenericNameSyntax gns)
            {
                return SyntaxFactory.ObjectCreationExpression(
                    SyntaxFactory
                        .GenericName(gns.Identifier)
                        .WithTypeArgumentList(
                            gns.TypeArgumentList
                        )
                ).WithArgumentList(SyntaxFactory.ArgumentList());
            }
            else if (p.Type is ArrayTypeSyntax ats)
            {
                return SyntaxFactory.InvocationExpression(
                    SyntaxFactory.MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        SyntaxFactory.IdentifierName("Array"),
                        SyntaxFactory
                            .GenericName(SyntaxFactory.Identifier("Empty"))
                            .WithTypeArgumentList(
                                SyntaxFactory.TypeArgumentList(
                                    SyntaxFactory.SingletonSeparatedList<TypeSyntax>(
                                        ats.ElementType
                                    )
                                )
                            )
                    )
                );
            }

            return SyntaxFactory.LiteralExpression(SyntaxKind.DefaultLiteralExpression, SyntaxFactory.Token(SyntaxKind.DefaultKeyword));
        }

        private PropertyDeclarationSyntax GenerateProperty(PropertyDeclarationSyntax p)
        {
            return p
                .WithModifiers(new SyntaxTokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)))
                .WithInitializer(SyntaxFactory.EqualsValueClause(FetchInitialiser(p)))
                .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        private MethodDeclarationSyntax GenerateMethod(MethodDeclarationSyntax m)
        {
            ReturnStatementSyntax rs = SyntaxFactory.ReturnStatement();

            if (m.ReturnType is PredefinedTypeSyntax pdt)
            {
                if (!pdt.Keyword.IsKind(SyntaxKind.VoidKeyword))
                {
                    rs = rs.WithExpression(
                        SyntaxFactory.LiteralExpression(SyntaxKind.DefaultLiteralExpression, SyntaxFactory.Token(SyntaxKind.DefaultKeyword))
                    );
                }
            }
            else if(m.ReturnType is IdentifierNameSyntax ins)
            {
                rs = rs.WithExpression(
                    SyntaxFactory
                        .ObjectCreationExpression(SyntaxFactory.IdentifierName(InterfaceToNullClassName(ins.Identifier.Text)))
                        .WithArgumentList(SyntaxFactory.ArgumentList())
                );
            }
            else
            {
                throw new ArgumentException("Unexpected return type in Method");
            }

            return SyntaxFactory
                .MethodDeclaration(m.AttributeLists, m.Modifiers, m.ReturnType, m.ExplicitInterfaceSpecifier, m.Identifier, m.TypeParameterList, m.ParameterList, m.ConstraintClauses, m.Body, null)
                .WithModifiers(new SyntaxTokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)))
                .WithBody(SyntaxFactory.Block(rs));
        }

        private string InterfaceToNullClassName(string name)
        {
            return $"Null{name.Substring(1)}";
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var markedInterfaces = FindMarkedInterfaces(context);

            foreach(var markedInterface in markedInterfaces)
            {
                var usings = FetchUsings(markedInterface);
                var namespaces = FetchNamespaces(markedInterface);

                var interfaceName = markedInterface.Identifier.Text;
                var className = InterfaceToNullClassName(interfaceName);

                var properties = FetchPropertiesToImplement(markedInterface).Select(p => GenerateProperty(p));
                var methods = FetchMethodsToImplement(markedInterface).Select(m => GenerateMethod(m));

                var genClass = GenerateClass(className, interfaceName, properties, methods);

                var ifName = FetchOriginalInterfaceName(markedInterface);

                var tree = GenerateRoot(genClass, namespaces, usings);
                var source = tree.NormalizeWhitespace().ToFullString();

                context.AddSource($"{ifName}.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
        
        public void Initialize(GeneratorInitializationContext context)
        {
        }
    }

}